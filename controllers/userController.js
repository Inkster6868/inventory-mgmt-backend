const asyncHandler=require("express-async-handler");
const User = require("../models/userModels");  //MODEL
const jwt=require("jsonwebtoken");
const bcrypt=require("bcryptjs");
const Token  = require("../models/tokenModel");  //MODEL
const crypto = require('crypto');
const sendEmail = require("../utils/sendEmail");   //FUNCTION




//Function 
const generateToken=(id)=>{
    return jwt.sign({ id },process.env.SECRET_KEY,{ expiresIn: "1d" });          //the first argument is the entry from which we want to create the token,
    // the second is the 'secret key' which is used to sign the entry that we want to create token from
    //the third is the amount of time after which we want this token to expire.
    //the token can be decrypted using jwt.io website if someone has my 'id' and the secret key used to sign it 
} ;


//REGISTER USER
const registerUser= asyncHandler( async(req,res)=>{   //the process of registering user will be an asynchronous task because interacting with the cloud is a 
const{name, email, password}=req.body;
if(!name||!email||!password){   //if anything is not present
    res.status(400)
    throw new Error("please fill in all required fields")  //this throws/generates a new error which will be then read by the error handler middleware before sending the reponse to the server
}

if(password.length<6){   //if length is less than 6 characters
    res.status(400)
    throw new Error("password length should be upto 6 characters")
}

//check if the email entered already exists or not. for this we need to interact with the databse
const userExists=await User.findOne({email}) //this email is the value that we are destructuring above from "req.body"
if(userExists){
    res.status(400)
    throw new Error("Email has already been registered")
}


//Create a new User
const user= await User.create({
    name,                                     //if entry is like this name:name then we can write only one time like this---> name
    email,      
    password
});


//GENERATE TOKEN
const token =generateToken(user._id); // we can create the token after user only because the id is generated by the mongodb and when the user has been created we can then only access the id.


//Send HTTP-only cookie to the frontend(client) in the form of a key:value pair (what this will do is when the y)
res.cookie("token",token,{
    path:'/',       // path means that at which endpoint should this cookie be sent and stored.
    httpOnly: true,  // read about this in '.txt' file
    expires: new Date(Date.now()+ 1000 * 86400), //techinically " 1000* 86400" this means one day, toh curent time jab user ne login kra usse leke aage tk ek dim 
    sameSite: "none", //allows the URL's of the frontend and backend to be different.read on '.txt' file
    secure:true, // means that we are only going to entertain 'https' requests to the server ,in development mode we only have access to the 'http' requests, so it will be of  no use to us, but when we deploy it this needs to be set 

});



if(user){
    const {_id, name, email, photo, phone, bio}=user //getting all the values of the user created 
    res.status(201).json({
            _id,
            name,
            email,
            photo,
            phone,
            bio,
            token,
    });
}
else{
    res.status(400);  //error generation //earlier we used res.send() to send the error response but it may conflict with sending http headers error. so we generate it
    throw new Error("Invalid user data");
}
});



//LOGIN USER
const loginUser=asyncHandler(async (req,res) =>{
            const {email, password}=req.body;

            //validate user
            if(!email || !password){
            res.status(400);
            throw new Error("please add email and password");
            }

            //check if the user exists
            const user=await User.findOne({email}) // this 'person' variable will have all the attributes of the user with the current given email if it exists
            // console.log(person)
            if(!user){
                 res.status(400);
                 throw new Error("User not found, please signup");
            }


            //user exists ,now check the password is correct or not, (till here we know the the person exits the database so we are using person.password)
            const passwordIsCorrect=await bcrypt.compare(password,user.password); // bcrypt also has the functionality to compare the hashed pass with the raw pass that the user enters
            //GENERATE TOKEN
            const token =generateToken(user._id); 
            // console.log(person._id);
            
            //if the password is valid then only send the cookie

            if(passwordIsCorrect){
            //Send the token through cookie
            res.cookie("token",token,{
            path:'/',   
            httpOnly: true, 
            expires: new Date(Date.now()+ 1000 * 86400),  
            sameSite:"none",
            secure:true  
            });
        }


            //now if both the things entered by the user are correct,then we send the repsonse to the server
            if(user && passwordIsCorrect){
                const {_id, name, email, photo, phone, bio}=user;
                res.status(200).json({      //200 because we created a new piece of entry so an "ok" status that it has been done.
                        _id,
                        name,
                        email,
                        photo,
                        phone,
                        bio,
                        token
                });
            } 
            else {
                res.status(400)
                throw new Error("Invalid password")
            }
});




//LOGOUT USER
const logout=asyncHandler(async(req,res)=>{ 
//Ok so we are able to keep the user logged in because of the cookie that we are sending what we will do is 'expire' the cookie to get the user logged out, we can also delete the cookie but expiring juust works fine so we just set the expire time to 0
  res.cookie("token","",{   //we just send an empty string in the token field
    path:"/",   
    httpOnly: true, 
    expires: new Date(0),  //expire the time
    sameSite:"none",
    secure:true
    });
    return res.status(200).json({message: "Successfully Logged Out"});
});



//GET USER INFO
//this is very precious to us as all the user data is being fetched from here.
//now suppose we open two tabs and are logged in with the same id in then if we click on logout from the other browser, the cookie is expired that means it will also logout from the other tab.
// so to show the user data first we will check that whether the user is logged in or not. that is whether the cookie is expired or is active then accordingly show the data

const getUser=asyncHandler(async(req,res)=>{
        const user=await User.findById(req.user._id);
        if(user){  //means if the user is present in the database then send it in the resposne

                const {_id,name,email,photo,phone,bio}=user;  //getting all the values of the user created 
                res.status(200).json({
                        _id,
                        name,
                        email,
                        photo,
                        phone,
                        bio
                    });
                  }
            
            else{
                res.status(400)  
                throw new Error("User not found");
            }
});



//CHECK IF LOGGED IN simply
const loginStatus=asyncHandler(async(req,res)=>{
        const token= await req.cookies.token;  //checking the token is present or not in the enpoint creating the request
        if(!token) {
            return res.json(false);
        } // if not then tell false

        //VERIFY TOKEN
         const verified=jwt.verify(token, process.env.SECRET_KEY);  // if present then verify
         if(verified)
         { return res.json(true);}  //if it i correct then say true

         return res.json(false); //else false
})


//Update User(except password)
const updateUser=asyncHandler(async(req,res)=>{
    const user=await User.findById(req.user._id) ; 
    if(user){
        const {name,email,photo,phone,bio}=user; //getting all the values of the user created 
        //now we want to change the fields that the user is requesting us to do, but we  will not allow user to change emails easily just like that so we will make the email remain as it is
        user.email=email;
        user.name=req.body.name || name; //if the user doesnt sent the name then we will let the name remain to what it was , we are going to do the same with every property
        user.phone=req.body.phone || phone;
        user.bio=req.body.bio || bio;
        user.photo=req.body.photo || photo;
        //we will handle the request to change the pass differently

        const updatedUser=await user.save();
        res.status(200).json({
            _id: updatedUser._id,
            name: updatedUser.name,
            email: updatedUser.email,
            photo: updatedUser.photo,
            phone: updatedUser.phone,
            bio: updatedUser.bio,
        });
    } else {
        res.status(404)
        throw new Error("User not found ")
    }
})

//Update User(changepassword)
const changePassword=asyncHandler(async(req,res)=>{
    const user=await User.findById(req.user._id); //find the user
    const{oldPassword,password}=req.body;  // the client will send both of the new password and the old password, to get their password updated

    if (!user) {
        res.status(400);
        throw new Error("User not found, please signup");
      }

   //Validate
  if (!oldPassword || !password) {
    res.status(400);
    throw new Error("Please add old and new password");
  }


    //comapre the' old password' with the credentials in the 'database'
    const passwordIsCorrect=await bcrypt.compare(oldPassword,user.password);
    
    //if the old password matches with the pass provided by the user, then update it in the daatabase
    if(user && passwordIsCorrect){
        user.password=password;
        await user.save();
        res.status(200).send("password changed successfully");
    }
    else{
        res.status(400);
        throw new Error("Old password is incorrect");
    }
    
});

//FORGOT PASSWORD
const forgotPassword=asyncHandler(async(req,res)=>{
    const {email}=req.body                   //the body will contain the email sent by the user for which he wants to reset password.
    const user=await User.findOne({email});
    // console.log(find);                     //check if some user with this email exits or not
    


    if(!user){                                    //if it doesn't then show error
                res.status(404);
                throw new Error("User does not exist");
    }

    //Also we want to delete the 'token' associated with the 'user' if it already exists in the "FORGOTTEN" model, that means if they would have reset the password anytime before a token would exist in the database,so suppose user again requests forgot pass after 2 weeks, but the token is valid only for "30 mins", so we need ot create a new token for 30 mins for that user
    let token= await Token.findOne({ userId : user._id })  //because the userId here has been referred to the 'user' schema, so 'find' will get all the details of that particular user if it exists, so we check by it

    if(token){   //we will delete it first, then a new token for 30 mins will created during code execution
            await token.deleteOne();  //deletes the whole entry for that particular user, and then assigns a whole new details to the same user
    }

    //Create Reset Token(using nodejs inbuilt 'crypto' library)
    let resetToken=crypto.randomBytes(32).toString("hex")+user._id;        //creates random32 chars, then we convert to string and specify it in the hex format, also to keep it unique we add the user id also with it.
    // console.log(resetToken);

    //Hash the reset token before storing it in the database
    const hashedToken=crypto.createHash("sha256").update(resetToken).digest("hex");        // we create a hash of the resetToken for security puposes before ssaving it to database. we specify the "sha256" algorithm to hash it and then tell what to hash using the .update() function, now to generate the final has we use .digest('hex).
    // console.log(hashToken);

    //save the Token to the "Forgotten" model.
    await new Token({
        userId: user._id,
        token: hashedToken,
        createdAt: Date.now(),
        expiresAt: Date.now() + 30 * (60 * 1000), // Thirty minutes
      }).save();

    //construct the 'reset url' which will be sent to the client.
    const resetURL=`${process.env.FRONTEND_URL}/resetpassword/${resetToken}`;          // now see we are not sending the hashed token here, we hased it to keep it ino ur database for the security purpose and later can compare it with the token received in URL whether it is correct or not

    //MAKING THE OPTIONS
    //'message'
    const message=`
    <h2>Hello ${user.name}</h2>
    <p>Please use the Url below to reset your password<p>
    <p>The reset link is valid for 30 minutes only</p>
    <a href=${resetURL}  clicktracking=off> ${resetURL} </a>          
    <p>Do not reply to this email</p>        <!-- as we will not be responding to the emails so we specify it before hand, or we can just add a email address that doesnt exist or we do not open it -->                    
    <p>Regards...</p>
    <p>Inventorymgmt Team</p>
    `
    //'subject'
    const subject="Password reset Request";
    
    //'send_to'
    const send_to=user.email;
    
    //'sent_from'
    const sent_from=process.env.EMAIL_USER
    
    //execute the sendEmail function (generally we wont use a try cath block but just to ensure that the email has been sent sucessfully, so that we can monitor if any error is there.
   try {
    await sendEmail(subject,message,send_to,sent_from);  //we will not be sending the reply_to email , it will work fine
    res.status(200).json({
        success:true,   
        message:"Reset email sent,Please check the Spam folder"
    })
   } catch (error) {
        res.status(500)
        throw new Error("Email not sent, Please try again")
        //there might be several reasons that we get error maybe our ISP is blaclisted or the IP that we are currenlty on is blacklisted, and many more reasons, so we will catch that error using this try catch block
   } 

})

//RESET PASSWORD(when the user clicks on the link we sent him through email, he will be redirected to this resetpassword site where he enters the new pasword)
const resetPassword=asyncHandler(async(req,res)=>{
    const{password}=req.body
    const{resetToken}=req.params    //now this token is not in the hashed form, but the one stored in our DB is in hashed form so we will also has this token the same way we hashed while saving it to our db.

    const hashedToken=crypto.createHash("sha256").update(resetToken).digest('hex');  // hashing the token we received from the params now we can easily compare the 2 values.
    //we find whether a user with the same token exists in our db or not 
    const userToken=await Token.findOne({
        token:hashedToken,
        expiresAt:{ $gt: Date.now() }  // also check whether the token has its time remaining, or has expired. its expiry time should be greater than the time at which the user has clicked on the link  
    })

    //if i do not find the token, or the token has expired then i show: 
    if(!userToken) {
        res.status(404)
        throw new Error("Invalid or expired token");
    }

    //if the Token is valid and hasn't expired, we will find the 'user' in the userModel using the 'userId' which will be equal to the 'objectId' of the user in consumers database. because we created a ref b/w the two in the "tokenModel"
    const user=await User.findOne({_id:userToken.userId});
    user.password=password;   // we update the password of that user in the db  with the password that we received from the user
    await user.save();
    res.status(200).json({
        message:"Password Reset Successfull, Please Login"
    });
});

module.exports={
    registerUser,
    loginUser,
    logout,
    getUser,
    loginStatus,
    updateUser,
    changePassword,
    forgotPassword,
    resetPassword
};